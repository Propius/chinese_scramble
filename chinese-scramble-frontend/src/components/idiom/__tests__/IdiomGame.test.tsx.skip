import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import IdiomGame from '../IdiomGame';

const mockOnSubmit = jest.fn();
const mockOnTimeout = jest.fn();
const mockOnHintRequest = jest.fn();

const defaultProps = {
  scrambledCharacters: ['é¾™', 'ç‚¹', 'ç”»', 'ç›'],
  correctAnswer: 'ç”»é¾™ç‚¹ç›',
  timeLimit: 120,
  onSubmit: mockOnSubmit,
  onTimeout: mockOnTimeout,
  onHintRequest: mockOnHintRequest,
  difficulty: 'ç®€å•',
};

const renderWithDnD = (ui: React.ReactElement) => {
  return render(
    <DndProvider backend={HTML5Backend}>
      {ui}
    </DndProvider>
  );
};

describe('IdiomGame Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('Rendering', () => {
    it('should render game header with correct difficulty', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/éš¾åº¦:/)).toBeInTheDocument();
      expect(screen.getByText(/ç®€å•/)).toBeInTheDocument();
    });

    it('should render timer with correct initial time', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/â±ï¸ 2:00/)).toBeInTheDocument();
    });

    it('should render hint counter as 0/3', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/ğŸ’¡ æç¤º: 0\/3/)).toBeInTheDocument();
    });

    it('should render all scrambled characters', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      defaultProps.scrambledCharacters.forEach(char => {
        expect(screen.getByText(char)).toBeInTheDocument();
      });
    });

    it('should render answer area with empty drop zones', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText('ğŸ“')).toBeInTheDocument();
      expect(screen.getByText(/ç­”æ¡ˆåŒºåŸŸ/)).toBeInTheDocument();
    });

    it('should render three hint buttons', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/æç¤º1: æˆè¯­å«ä¹‰/)).toBeInTheDocument();
      expect(screen.getByText(/æç¤º2: ç¬¬ä¸€ä¸ªå­—/)).toBeInTheDocument();
      expect(screen.getByText(/æç¤º3: ç”¨æ³•ç¤ºä¾‹/)).toBeInTheDocument();
    });

    it('should render reset and submit buttons', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/ğŸ”„ é‡ç½®/)).toBeInTheDocument();
      expect(screen.getByText(/âœ“ æäº¤ç­”æ¡ˆ/)).toBeInTheDocument();
    });
  });

  describe('Timer Functionality', () => {
    it('should countdown timer every second', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/â±ï¸ 2:00/)).toBeInTheDocument();

      jest.advanceTimersByTime(1000);
      expect(screen.getByText(/â±ï¸ 1:59/)).toBeInTheDocument();

      jest.advanceTimersByTime(10000);
      expect(screen.getByText(/â±ï¸ 1:49/)).toBeInTheDocument();
    });

    it('should call onTimeout when timer reaches zero', () => {
      renderWithDnD(<IdiomGame {...defaultProps} timeLimit={3} />);

      jest.advanceTimersByTime(4000);

      expect(mockOnTimeout).toHaveBeenCalledTimes(1);
    });

    it('should format timer correctly for single digit seconds', () => {
      renderWithDnD(<IdiomGame {...defaultProps} timeLimit={65} />);

      expect(screen.getByText(/â±ï¸ 1:05/)).toBeInTheDocument();
    });
  });

  describe('Hint System', () => {
    it('should request hint level 1 when clicking hint 1 button', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      const hint1Button = screen.getByText(/æç¤º1: æˆè¯­å«ä¹‰/);
      fireEvent.click(hint1Button);

      expect(mockOnHintRequest).toHaveBeenCalledWith(1);
    });

    it('should request hint level 2 when clicking hint 2 button', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      const hint2Button = screen.getByText(/æç¤º2: ç¬¬ä¸€ä¸ªå­—/);
      fireEvent.click(hint2Button);

      expect(mockOnHintRequest).toHaveBeenCalledWith(2);
    });

    it('should request hint level 3 when clicking hint 3 button', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      const hint3Button = screen.getByText(/æç¤º3: ç”¨æ³•ç¤ºä¾‹/);
      fireEvent.click(hint3Button);

      expect(mockOnHintRequest).toHaveBeenCalledWith(3);
    });

    it('should increment hints used counter when hint is requested', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/ğŸ’¡ æç¤º: 0\/3/)).toBeInTheDocument();

      const hint1Button = screen.getByText(/æç¤º1: æˆè¯­å«ä¹‰/);
      fireEvent.click(hint1Button);

      expect(screen.getByText(/ğŸ’¡ æç¤º: 1\/3/)).toBeInTheDocument();
    });

    it('should disable hint buttons after 3 hints used', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      const hint1Button = screen.getByText(/æç¤º1: æˆè¯­å«ä¹‰/);

      fireEvent.click(hint1Button);
      fireEvent.click(hint1Button);
      fireEvent.click(hint1Button);

      expect(screen.getByText(/ğŸ’¡ æç¤º: 3\/3/)).toBeInTheDocument();
      expect(hint1Button).toBeDisabled();
    });

    it('should display hint text when hint prop is provided', () => {
      const hintText = 'è¿™ä¸ªæˆè¯­çš„æ„æ€æ˜¯æ¯”å–»åœ¨å…³é”®åœ°æ–¹åŠ ä¸Šä¸€ç¬”';
      renderWithDnD(<IdiomGame {...defaultProps} hint={hintText} />);

      expect(screen.getByText(/ğŸ’¡ æç¤º/)).toBeInTheDocument();
      expect(screen.getByText(hintText)).toBeInTheDocument();
    });

    it('should show remaining hints count', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/(3 æ¬¡å¯ç”¨)/)).toBeInTheDocument();

      const hint1Button = screen.getByText(/æç¤º1: æˆè¯­å«ä¹‰/);
      fireEvent.click(hint1Button);

      expect(screen.getByText(/(2 æ¬¡å¯ç”¨)/)).toBeInTheDocument();
    });
  });

  describe('Submit Functionality', () => {
    it('should disable submit button when not all characters placed', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      const submitButton = screen.getByText(/âœ“ æäº¤ç­”æ¡ˆ/);
      expect(submitButton).toBeDisabled();
    });

    it('should show alert when submitting incomplete answer', () => {
      window.alert = jest.fn();
      renderWithDnD(<IdiomGame {...defaultProps} />);

      const submitButton = screen.getByText(/âœ“ æäº¤ç­”æ¡ˆ/);
      fireEvent.click(submitButton);

      expect(window.alert).toHaveBeenCalledWith('è¯·å®Œæˆæ‰€æœ‰å­—ç¬¦çš„æ’åˆ—ï¼(Please place all characters!)');
    });

    it('should change button text to "æäº¤ä¸­..." when submitting', async () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      // Simulate all characters placed (this would require drag-and-drop simulation)
      // For now, we test the disabled state
      const submitButton = screen.getByText(/âœ“ æäº¤ç­”æ¡ˆ/);
      expect(submitButton).toBeInTheDocument();
    });

    it('should calculate time taken correctly on submit', () => {
      jest.useRealTimers();
      const startTime = Date.now();
      jest.useFakeTimers().setSystemTime(startTime);

      renderWithDnD(<IdiomGame {...defaultProps} />);

      // Advance time by 5 seconds
      jest.advanceTimersByTime(5000);

      // Note: Full submit test would require drag-and-drop simulation
      // which is complex with react-dnd and HTML5Backend
    });
  });

  describe('Reset Functionality', () => {
    it('should have reset button enabled', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      const resetButton = screen.getByText(/ğŸ”„ é‡ç½®/);
      expect(resetButton).not.toBeDisabled();
    });

    it('should disable reset button when submitting', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      // Set isSubmitting state would require interaction
      // Testing button exists and has proper class
      const resetButton = screen.getByText(/ğŸ”„ é‡ç½®/);
      expect(resetButton).toHaveClass('bg-gray-500');
    });
  });

  describe('Progress Indicator', () => {
    it('should render progress indicator', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/å·²å®Œæˆ: 0 \/ 4/)).toBeInTheDocument();
    });

    it('should show progress bar with 0% initially', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      const progressBar = screen.getByText(/å·²å®Œæˆ:/).parentElement?.querySelector('.bg-gradient-to-r');
      expect(progressBar).toHaveStyle({ width: '0%' });
    });
  });

  describe('Difficulty Display', () => {
    it('should display EASY difficulty correctly', () => {
      renderWithDnD(<IdiomGame {...defaultProps} difficulty="ç®€å•" />);
      expect(screen.getByText(/éš¾åº¦: ç®€å•/)).toBeInTheDocument();
    });

    it('should display MEDIUM difficulty correctly', () => {
      renderWithDnD(<IdiomGame {...defaultProps} difficulty="ä¸­ç­‰" />);
      expect(screen.getByText(/éš¾åº¦: ä¸­ç­‰/)).toBeInTheDocument();
    });

    it('should display HARD difficulty correctly', () => {
      renderWithDnD(<IdiomGame {...defaultProps} difficulty="å›°éš¾" />);
      expect(screen.getByText(/éš¾åº¦: å›°éš¾/)).toBeInTheDocument();
    });

    it('should display EXPERT difficulty correctly', () => {
      renderWithDnD(<IdiomGame {...defaultProps} difficulty="ä¸“å®¶" />);
      expect(screen.getByText(/éš¾åº¦: ä¸“å®¶/)).toBeInTheDocument();
    });
  });

  describe('UI Instructions', () => {
    it('should display game instructions', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/ğŸ“ æ¸¸æˆè¯´æ˜/)).toBeInTheDocument();
      expect(screen.getByText(/æ‹–åŠ¨ä¸‹æ–¹çš„å­—ç¬¦åˆ°ç­”æ¡ˆåŒºåŸŸï¼ŒæŒ‰æ­£ç¡®é¡ºåºæ’åˆ—æˆè¯­ã€‚ç‚¹å‡»å·²æ”¾ç½®çš„å­—ç¬¦å¯ä»¥ç§»é™¤ã€‚/)).toBeInTheDocument();
    });

    it('should display hint for answer area', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/ğŸ’¡ æç¤º: æ‹–åŠ¨ä¸‹æ–¹å­—ç¬¦åˆ°ç­”æ¡ˆåŒºï¼Œæˆ–ç‚¹å‡»å·²æ”¾ç½®çš„å­—ç¬¦ç§»é™¤/)).toBeInTheDocument();
    });

    it('should display hint for available characters', () => {
      renderWithDnD(<IdiomGame {...defaultProps} />);

      expect(screen.getByText(/ğŸ‘† æ‹–åŠ¨å­—ç¬¦åˆ°ä¸Šæ–¹ç­”æ¡ˆåŒºåŸŸ/)).toBeInTheDocument();
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty scrambled characters', () => {
      renderWithDnD(<IdiomGame {...defaultProps} scrambledCharacters={[]} />);

      expect(screen.getByText(/ç­”æ¡ˆåŒºåŸŸ/)).toBeInTheDocument();
    });

    it('should handle very short time limit', () => {
      renderWithDnD(<IdiomGame {...defaultProps} timeLimit={1} />);

      expect(screen.getByText(/â±ï¸ 0:01/)).toBeInTheDocument();

      jest.advanceTimersByTime(2000);
      expect(mockOnTimeout).toHaveBeenCalled();
    });

    it('should handle very long time limit', () => {
      renderWithDnD(<IdiomGame {...defaultProps} timeLimit={3600} />);

      expect(screen.getByText(/â±ï¸ 60:00/)).toBeInTheDocument();
    });
  });
});
